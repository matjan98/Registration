/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.2.0.0 (NJsonSchema v10.1.2.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

export class ClientBase {
    protected transformOptions(requestInit: RequestInit): Promise<RequestInit> {
        if(requestInit && requestInit.headers){
            (requestInit.headers as any).Authorization = "Bearer " + localStorage.getItem("Token");
        }
        return Promise.resolve<RequestInit>(<any>requestInit);
    }

    protected transformResult(url: string, response: Response, processor: (response: Response) => any) {
        console.log("Service call: " + url);
        return processor(response); 
    }
}

export interface IApiClient {
    dateParser(dateTicks: number | null | undefined): Promise<DataResult>;
    timeSpanParser(timeTicks: number | null | undefined): Promise<DataResult>;
    testApi(): Promise<DataResult>;
    logIn(username: string | null | undefined, password: string | null | undefined): Promise<DataResult>;
    whoami(): Promise<DataResult>;
    register(first_name: string | null | undefined, last_name: string | null | undefined, username: string | null | undefined, password: string | null | undefined, doctor: boolean | undefined): Promise<DataResult>;
    bookAnAppointmentWithDoctor(doctorID: number | undefined, dateTime: number | null | undefined): Promise<DataResult>;
    cancelAnAppointmentWithDoctor(reserwationID: number | undefined): Promise<DataResult>;
    listBookedAppointments(): Promise<DataResult>;
    listDoctorAccesibility(doctorID: number | undefined, dateTimeFrom: number | null | undefined, dateTimeTo: number | null | undefined): Promise<DataResult>;
    listDoctors(): Promise<DataResult>;
    seeAllRequests(dateTimeFrom: number | null | undefined, dateTimeTo: number | null | undefined): Promise<DataResult>;
    setSpecialization(specialization: string | null | undefined): Promise<DataResult>;
    setWorkingTime(timeSpanFrom: number | null | undefined, timeSpanTo: number | null | undefined): Promise<DataResult>;
    createReservation(doctorID: number | undefined, patientID: number | undefined, datetime: number | null | undefined): Promise<DataResult>;
    setPerrmisions(userID: number | undefined, accountType: AccountType | undefined): Promise<DataResult>;
    removeUser(userID: number | undefined): Promise<DataResult>;
    cancelReservation(reservationID: number | undefined): Promise<DataResult>;
    addUser(first_name: string | null | undefined, last_name: string | null | undefined, username: string | null | undefined, password: string | null | undefined, accountType: AccountType | undefined): Promise<DataResult>;
    listAllUsers(): Promise<DataResult>;
    devHelper(): Promise<AllModels>;
}

export class ApiClient extends ClientBase implements IApiClient {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super();
        this.http = http ? http : <any>window;
        this.baseUrl = baseUrl ? baseUrl : "http://localhost:5000";
    }

    dateParser(dateTicks: number | null | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/DateParser?";
        if (dateTicks !== undefined)
            url_ += "dateTicks=" + encodeURIComponent("" + dateTicks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDateParser(_response);
        });
    }

    protected processDateParser(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    timeSpanParser(timeTicks: number | null | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/TimeSpanParser?";
        if (timeTicks !== undefined)
            url_ += "timeTicks=" + encodeURIComponent("" + timeTicks) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTimeSpanParser(_response);
        });
    }

    protected processTimeSpanParser(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    testApi(): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/TestApi";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processTestApi(_response);
        });
    }

    protected processTestApi(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    logIn(username: string | null | undefined, password: string | null | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/LogIn?";
        if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processLogIn(_response);
        });
    }

    protected processLogIn(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    whoami(): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/Whoami";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processWhoami(_response);
        });
    }

    protected processWhoami(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    register(first_name: string | null | undefined, last_name: string | null | undefined, username: string | null | undefined, password: string | null | undefined, doctor: boolean | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/Register?";
        if (first_name !== undefined)
            url_ += "first_name=" + encodeURIComponent("" + first_name) + "&"; 
        if (last_name !== undefined)
            url_ += "last_name=" + encodeURIComponent("" + last_name) + "&"; 
        if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        if (doctor === null)
            throw new Error("The parameter 'doctor' cannot be null.");
        else if (doctor !== undefined)
            url_ += "doctor=" + encodeURIComponent("" + doctor) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRegister(_response);
        });
    }

    protected processRegister(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    bookAnAppointmentWithDoctor(doctorID: number | undefined, dateTime: number | null | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/BookAnAppointmentWithDoctor?";
        if (doctorID === null)
            throw new Error("The parameter 'doctorID' cannot be null.");
        else if (doctorID !== undefined)
            url_ += "doctorID=" + encodeURIComponent("" + doctorID) + "&"; 
        if (dateTime !== undefined)
            url_ += "dateTime=" + encodeURIComponent("" + dateTime) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processBookAnAppointmentWithDoctor(_response);
        });
    }

    protected processBookAnAppointmentWithDoctor(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    cancelAnAppointmentWithDoctor(reserwationID: number | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/CancelAnAppointmentWithDoctor?";
        if (reserwationID === null)
            throw new Error("The parameter 'reserwationID' cannot be null.");
        else if (reserwationID !== undefined)
            url_ += "reserwationID=" + encodeURIComponent("" + reserwationID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancelAnAppointmentWithDoctor(_response);
        });
    }

    protected processCancelAnAppointmentWithDoctor(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    listBookedAppointments(): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/ListBookedAppointments";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListBookedAppointments(_response);
        });
    }

    protected processListBookedAppointments(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    listDoctorAccesibility(doctorID: number | undefined, dateTimeFrom: number | null | undefined, dateTimeTo: number | null | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/ListDoctorAccesibility?";
        if (doctorID === null)
            throw new Error("The parameter 'doctorID' cannot be null.");
        else if (doctorID !== undefined)
            url_ += "doctorID=" + encodeURIComponent("" + doctorID) + "&"; 
        if (dateTimeFrom !== undefined)
            url_ += "dateTimeFrom=" + encodeURIComponent("" + dateTimeFrom) + "&"; 
        if (dateTimeTo !== undefined)
            url_ += "dateTimeTo=" + encodeURIComponent("" + dateTimeTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListDoctorAccesibility(_response);
        });
    }

    protected processListDoctorAccesibility(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    listDoctors(): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/ListDoctors";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListDoctors(_response);
        });
    }

    protected processListDoctors(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    seeAllRequests(dateTimeFrom: number | null | undefined, dateTimeTo: number | null | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/SeeAllRequests?";
        if (dateTimeFrom !== undefined)
            url_ += "dateTimeFrom=" + encodeURIComponent("" + dateTimeFrom) + "&"; 
        if (dateTimeTo !== undefined)
            url_ += "dateTimeTo=" + encodeURIComponent("" + dateTimeTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSeeAllRequests(_response);
        });
    }

    protected processSeeAllRequests(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    setSpecialization(specialization: string | null | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/SetSpecialization?";
        if (specialization !== undefined)
            url_ += "specialization=" + encodeURIComponent("" + specialization) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetSpecialization(_response);
        });
    }

    protected processSetSpecialization(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    setWorkingTime(timeSpanFrom: number | null | undefined, timeSpanTo: number | null | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/SetWorkingTime?";
        if (timeSpanFrom !== undefined)
            url_ += "timeSpanFrom=" + encodeURIComponent("" + timeSpanFrom) + "&"; 
        if (timeSpanTo !== undefined)
            url_ += "timeSpanTo=" + encodeURIComponent("" + timeSpanTo) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetWorkingTime(_response);
        });
    }

    protected processSetWorkingTime(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    createReservation(doctorID: number | undefined, patientID: number | undefined, datetime: number | null | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/CreateReservation?";
        if (doctorID === null)
            throw new Error("The parameter 'doctorID' cannot be null.");
        else if (doctorID !== undefined)
            url_ += "doctorID=" + encodeURIComponent("" + doctorID) + "&"; 
        if (patientID === null)
            throw new Error("The parameter 'patientID' cannot be null.");
        else if (patientID !== undefined)
            url_ += "patientID=" + encodeURIComponent("" + patientID) + "&"; 
        if (datetime !== undefined)
            url_ += "datetime=" + encodeURIComponent("" + datetime) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCreateReservation(_response);
        });
    }

    protected processCreateReservation(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    setPerrmisions(userID: number | undefined, accountType: AccountType | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/SetPerrmisions?";
        if (userID === null)
            throw new Error("The parameter 'userID' cannot be null.");
        else if (userID !== undefined)
            url_ += "userID=" + encodeURIComponent("" + userID) + "&"; 
        if (accountType === null)
            throw new Error("The parameter 'accountType' cannot be null.");
        else if (accountType !== undefined)
            url_ += "accountType=" + encodeURIComponent("" + accountType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processSetPerrmisions(_response);
        });
    }

    protected processSetPerrmisions(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    removeUser(userID: number | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/RemoveUser?";
        if (userID === null)
            throw new Error("The parameter 'userID' cannot be null.");
        else if (userID !== undefined)
            url_ += "userID=" + encodeURIComponent("" + userID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processRemoveUser(_response);
        });
    }

    protected processRemoveUser(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    cancelReservation(reservationID: number | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/CancelReservation?";
        if (reservationID === null)
            throw new Error("The parameter 'reservationID' cannot be null.");
        else if (reservationID !== undefined)
            url_ += "reservationID=" + encodeURIComponent("" + reservationID) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processCancelReservation(_response);
        });
    }

    protected processCancelReservation(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    addUser(first_name: string | null | undefined, last_name: string | null | undefined, username: string | null | undefined, password: string | null | undefined, accountType: AccountType | undefined): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/AddUser?";
        if (first_name !== undefined)
            url_ += "first_name=" + encodeURIComponent("" + first_name) + "&"; 
        if (last_name !== undefined)
            url_ += "last_name=" + encodeURIComponent("" + last_name) + "&"; 
        if (username !== undefined)
            url_ += "username=" + encodeURIComponent("" + username) + "&"; 
        if (password !== undefined)
            url_ += "password=" + encodeURIComponent("" + password) + "&"; 
        if (accountType === null)
            throw new Error("The parameter 'accountType' cannot be null.");
        else if (accountType !== undefined)
            url_ += "accountType=" + encodeURIComponent("" + accountType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processAddUser(_response);
        });
    }

    protected processAddUser(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    listAllUsers(): Promise<DataResult> {
        let url_ = this.baseUrl + "/Api/ListAllUsers";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processListAllUsers(_response);
        });
    }

    protected processListAllUsers(response: Response): Promise<DataResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataResult.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<DataResult>(<any>null);
    }

    devHelper(): Promise<AllModels> {
        let url_ = this.baseUrl + "/Api/DevHelper";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <RequestInit>{
            method: "GET",
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.processDevHelper(_response);
        });
    }

    protected processDevHelper(response: Response): Promise<AllModels> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AllModels.fromJS(resultData200);
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<AllModels>(<any>null);
    }
}

export class DataResult implements IDataResult {
    status!: RequestStatus;
    data?: any | undefined;

    constructor(data?: IDataResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["status"];
            this.data = _data["data"];
        }
    }

    static fromJS(data: any): DataResult {
        data = typeof data === 'object' ? data : {};
        let result = new DataResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["status"] = this.status;
        data["data"] = this.data;
        return data; 
    }
}

export interface IDataResult {
    status: RequestStatus;
    data?: any | undefined;
}

export enum RequestStatus {
    Success = 0,
    Fail = 1,
    Forbidden = 2,
    WrongData = 3,
}

export enum AccountType {
    Patient = 0,
    Doctor = 1,
    Admin = 2,
}

export class AllModels implements IAllModels {
    bookedAppointment?: BookedAppointment | undefined;
    doctorAccessiblity?: DoctorAccessiblity | undefined;
    doctorModel?: DoctorModel | undefined;
    requestModel?: RequestModel | undefined;
    userModel?: UserModel | undefined;

    constructor(data?: IAllModels) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.bookedAppointment = _data["bookedAppointment"] ? BookedAppointment.fromJS(_data["bookedAppointment"]) : <any>undefined;
            this.doctorAccessiblity = _data["doctorAccessiblity"] ? DoctorAccessiblity.fromJS(_data["doctorAccessiblity"]) : <any>undefined;
            this.doctorModel = _data["doctorModel"] ? DoctorModel.fromJS(_data["doctorModel"]) : <any>undefined;
            this.requestModel = _data["requestModel"] ? RequestModel.fromJS(_data["requestModel"]) : <any>undefined;
            this.userModel = _data["userModel"] ? UserModel.fromJS(_data["userModel"]) : <any>undefined;
        }
    }

    static fromJS(data: any): AllModels {
        data = typeof data === 'object' ? data : {};
        let result = new AllModels();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["bookedAppointment"] = this.bookedAppointment ? this.bookedAppointment.toJSON() : <any>undefined;
        data["doctorAccessiblity"] = this.doctorAccessiblity ? this.doctorAccessiblity.toJSON() : <any>undefined;
        data["doctorModel"] = this.doctorModel ? this.doctorModel.toJSON() : <any>undefined;
        data["requestModel"] = this.requestModel ? this.requestModel.toJSON() : <any>undefined;
        data["userModel"] = this.userModel ? this.userModel.toJSON() : <any>undefined;
        return data; 
    }
}

export interface IAllModels {
    bookedAppointment?: BookedAppointment | undefined;
    doctorAccessiblity?: DoctorAccessiblity | undefined;
    doctorModel?: DoctorModel | undefined;
    requestModel?: RequestModel | undefined;
    userModel?: UserModel | undefined;
}

export class BookedAppointment implements IBookedAppointment {
    dateTime!: Date;
    doctorFirstName?: string | undefined;
    doctorLastName?: string | undefined;
    doctorSpecializaion?: string | undefined;
    doctorID!: number;

    constructor(data?: IBookedAppointment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.doctorFirstName = _data["doctorFirstName"];
            this.doctorLastName = _data["doctorLastName"];
            this.doctorSpecializaion = _data["doctorSpecializaion"];
            this.doctorID = _data["doctorID"];
        }
    }

    static fromJS(data: any): BookedAppointment {
        data = typeof data === 'object' ? data : {};
        let result = new BookedAppointment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["doctorFirstName"] = this.doctorFirstName;
        data["doctorLastName"] = this.doctorLastName;
        data["doctorSpecializaion"] = this.doctorSpecializaion;
        data["doctorID"] = this.doctorID;
        return data; 
    }
}

export interface IBookedAppointment {
    dateTime: Date;
    doctorFirstName?: string | undefined;
    doctorLastName?: string | undefined;
    doctorSpecializaion?: string | undefined;
    doctorID: number;
}

export class DoctorAccessiblity implements IDoctorAccessiblity {
    visits?: Date[] | undefined;
    visitTimeInMinutes!: number;
    workingTimeFrom!: string;
    workingTimeTo!: string;

    constructor(data?: IDoctorAccessiblity) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["visits"])) {
                this.visits = [] as any;
                for (let item of _data["visits"])
                    this.visits!.push(new Date(item));
            }
            this.visitTimeInMinutes = _data["visitTimeInMinutes"];
            this.workingTimeFrom = _data["workingTimeFrom"];
            this.workingTimeTo = _data["workingTimeTo"];
        }
    }

    static fromJS(data: any): DoctorAccessiblity {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorAccessiblity();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.visits)) {
            data["visits"] = [];
            for (let item of this.visits)
                data["visits"].push(item.toISOString());
        }
        data["visitTimeInMinutes"] = this.visitTimeInMinutes;
        data["workingTimeFrom"] = this.workingTimeFrom;
        data["workingTimeTo"] = this.workingTimeTo;
        return data; 
    }
}

export interface IDoctorAccessiblity {
    visits?: Date[] | undefined;
    visitTimeInMinutes: number;
    workingTimeFrom: string;
    workingTimeTo: string;
}

export class DoctorModel implements IDoctorModel {
    firstName?: string | undefined;
    id!: number;
    lastLogged!: Date;
    lastName?: string | undefined;
    specialization?: string | undefined;

    constructor(data?: IDoctorModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.id = _data["id"];
            this.lastLogged = _data["lastLogged"] ? new Date(_data["lastLogged"].toString()) : <any>undefined;
            this.lastName = _data["lastName"];
            this.specialization = _data["specialization"];
        }
    }

    static fromJS(data: any): DoctorModel {
        data = typeof data === 'object' ? data : {};
        let result = new DoctorModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["id"] = this.id;
        data["lastLogged"] = this.lastLogged ? this.lastLogged.toISOString() : <any>undefined;
        data["lastName"] = this.lastName;
        data["specialization"] = this.specialization;
        return data; 
    }
}

export interface IDoctorModel {
    firstName?: string | undefined;
    id: number;
    lastLogged: Date;
    lastName?: string | undefined;
    specialization?: string | undefined;
}

export class RequestModel implements IRequestModel {
    dateTime!: Date;
    patientFirstName?: string | undefined;
    patientLastName?: string | undefined;
    patientID!: number;

    constructor(data?: IRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
            this.patientFirstName = _data["patientFirstName"];
            this.patientLastName = _data["patientLastName"];
            this.patientID = _data["patientID"];
        }
    }

    static fromJS(data: any): RequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new RequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
        data["patientFirstName"] = this.patientFirstName;
        data["patientLastName"] = this.patientLastName;
        data["patientID"] = this.patientID;
        return data; 
    }
}

export interface IRequestModel {
    dateTime: Date;
    patientFirstName?: string | undefined;
    patientLastName?: string | undefined;
    patientID: number;
}

export class UserModel implements IUserModel {
    firstName?: string | undefined;
    lastName?: string | undefined;
    id!: number;
    accountType!: AccountType;
    lastLogged!: Date;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.id = _data["id"];
            this.accountType = _data["accountType"];
            this.lastLogged = _data["lastLogged"] ? new Date(_data["lastLogged"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["id"] = this.id;
        data["accountType"] = this.accountType;
        data["lastLogged"] = this.lastLogged ? this.lastLogged.toISOString() : <any>undefined;
        return data; 
    }
}

export interface IUserModel {
    firstName?: string | undefined;
    lastName?: string | undefined;
    id: number;
    accountType: AccountType;
    lastLogged: Date;
}

export class ApiException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new ApiException(message, status, response, headers, null);
}